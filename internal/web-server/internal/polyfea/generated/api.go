//go:build go1.22

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"fmt"
	"net/http"

	"github.com/oapi-codegen/runtime"
)

// Defines values for MicrofrontendResourceKind.
const (
	Link       MicrofrontendResourceKind = "link"
	Script     MicrofrontendResourceKind = "script"
	Stylesheet MicrofrontendResourceKind = "stylesheet"
)

// ContextArea Elements to be inserted into the microfrontend context area.
// The context area refers to a section in the document flow, the content of which depends
// on the system's configuration. For instance, the context area `top-level-application`
// could be used to render the top-level application tiles.
type ContextArea struct {
	// Elements The elements to be incorporated into the context area.
	// These elements will be rendered in the sequence they appear in the array.
	Elements []ElementSpec `json:"elements"`

	// Microfrontends The microfrontends referenced by any of the elements. The browser triggers
	// the loading of microfrontend resources when the element is rendered.
	Microfrontends *map[string]MicrofrontendSpec `json:"microfrontends,omitempty"`
}

// ElementSpec Specification of the element.
// Elements serve as the building blocks of the application.
// Each element should be a web component rendered by the browser.
// When rendered in context, such as with the `polyfea-context` element,
// the `context` attribute is set to the name of the context area.
type ElementSpec struct {
	// Attributes Attributes to be assigned to the element during rendering.
	Attributes *map[string]string `json:"attributes,omitempty"`

	// Microfrontend The name of the microfrontend to which the element belongs. The browser
	// loads the microfrontend before rendering the element.
	// If this property is not provided, it's assumed that the browser has already
	// loaded all necessary resources for the element prior to rendering.
	Microfrontend *string `json:"microfrontend,omitempty"`

	// Style The styles of the element. Primarily intended as a fallback for specific cases,
	// such as setting CSS variables.
	Style *map[string]string `json:"style,omitempty"`

	// TagName The name of the element, which corresponds to its tag name used in the document flow.
	TagName string `json:"tagName"`
}

// MicrofrontendResource The resource that the microfrontend requires. This resource could be a script,
// stylesheet, or any other `link` element. The browser loads this resource when the
// microfrontend is requested. The loading process can occur either synchronously or asynchronously.
type MicrofrontendResource struct {
	// Attributes Additional attributes to be assigned to the `link` or `script` element,
	// alongside the `rel` and `href` attributes.
	Attributes *map[string]string `json:"attributes,omitempty"`

	// Href The URL of the resource. This URL is usually relative to the application's base URL
	// and is typically served as a subpath
	// of `<base_href>/polyfea/webcomponent/<microfrontend-name>/<resource-path...>`.
	Href *string `json:"href,omitempty"`

	// Kind The type of the resource. This could be a script, stylesheet, or any other `link` element.
	Kind *MicrofrontendResourceKind `json:"kind,omitempty"`

	// WaitOnLoad If set to `true`, the browser will complete loading the resource before it finishes
	// loading the microfrontend. If set to `false`, the browser will load the resource
	// asynchronously, allowing for continued loading and rendering in the meantime.
	WaitOnLoad *bool `json:"waitOnLoad,omitempty"`
}

// MicrofrontendResourceKind The type of the resource. This could be a script, stylesheet, or any other `link` element.
type MicrofrontendResourceKind string

// MicrofrontendSpec Specification of the microfrontend.
// Microfrontend resources are loaded by the browser as needed.
// Each microfrontend comprises a set of resources that are loaded prior to,
// or in parallel with, the rendering of microfrontend elements.
// Additionally, a microfrontend can have dependencies on other microfrontends.
type MicrofrontendSpec struct {
	// DependsOn The microfrontends that this microfrontend depends on.
	// The specification of these dependencies is provided in the context area information.
	DependsOn *[]string `json:"dependsOn,omitempty"`

	// Module A shorthand for the microfrontend script module resource. The browser loads this module before rendering the elements. If the module has dependencies on other resources, it may load them itself, provided their references are given as a relative path to the module.
	Module *string `json:"module,omitempty"`

	// Resources The resources that the browser should load. Only resources that need to be directly
	// loaded into the document's `head` element should be specified here. Typical examples
	// include fonts and stylesheets that must be globally available.
	Resources *[]MicrofrontendResource `json:"resources,omitempty"`
}

// StaticConfig Specification of the application's static configuration.
// This configuration is a compilation of all contexts/paths and their elements.
// It's particularly useful during development, testing, or for simpler applications.
type StaticConfig struct {
	// ContextAreas A list of context areas along with their elements. Each context area is identified by its
	// name and the regex path where it's rendered. In the event of a conflict, the first matching
	// context area is selected.
	ContextAreas *[]StaticConfigArea `json:"contextAreas,omitempty"`

	// Microfrontends A dictionary of microfrontends, each identified by its unique name.
	Microfrontends map[string]MicrofrontendSpec `json:"microfrontends"`
}

// StaticConfigArea Specification of the static configuration for a context area,
// identified by a specific name and path regex.
type StaticConfigArea struct {
	// ContextArea Elements to be inserted into the microfrontend context area.
	// The context area refers to a section in the document flow, the content of which depends
	// on the system's configuration. For instance, the context area `top-level-application`
	// could be used to render the top-level application tiles.
	ContextArea *ContextArea `json:"contextArea,omitempty"`

	// Name Name of the context area.
	Name string `json:"name"`

	// Path The regular expression used to match the path relative to the base href
	// where this context area should be applied. If no path is provided, the
	// context area specification applies to all paths. In the event of conflicts,
	// the first matching context area is used.
	Path *string `json:"path,omitempty"`
}

// GetContextAreaParams defines parameters for GetContextArea.
type GetContextAreaParams struct {
	// Path The relative path from the base href where the context area should be displayed.
	Path string `form:"path" json:"path"`

	// Take The number of elements the client should consume. Elements are consumed in
	// the order they are provided. If not specified, all provided elements will be used.
	Take *int `form:"take,omitempty" json:"take,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get the context area information.
	// (GET /context-area/{name})
	GetContextArea(w http.ResponseWriter, r *http.Request, name string, params GetContextAreaParams)
	// Get the static information about all resources and context areas.
	// (GET /static-config)
	GetStaticConfig(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetContextArea operation middleware
func (siw *ServerInterfaceWrapper) GetContextArea(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContextAreaParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "take" -------------

	err = runtime.BindQueryParameter("form", true, false, "take", r.URL.Query(), &params.Take)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "take", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetContextArea(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStaticConfig operation middleware
func (siw *ServerInterfaceWrapper) GetStaticConfig(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStaticConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/context-area/{name}", wrapper.GetContextArea)
	m.HandleFunc("GET "+options.BaseURL+"/static-config", wrapper.GetStaticConfig)

	return m
}
